// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task_specification.proto

#ifndef PROTOBUF_task_5fspecification_2eproto__INCLUDED
#define PROTOBUF_task_5fspecification_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "task_action.pb.h"
#include "time.pb.h"
// @@protoc_insertion_point(includes)

namespace mission_protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_5fspecification_2eproto();
void protobuf_AssignDesc_task_5fspecification_2eproto();
void protobuf_ShutdownFile_task_5fspecification_2eproto();

class NavigationTask;
class TransportationTask;
class Task;

enum NavigationTask_Orientation {
  NavigationTask_Orientation_NORTH = 1,
  NavigationTask_Orientation_EAST = 2,
  NavigationTask_Orientation_SOUTH = 3,
  NavigationTask_Orientation_WEST = 4
};
bool NavigationTask_Orientation_IsValid(int value);
const NavigationTask_Orientation NavigationTask_Orientation_Orientation_MIN = NavigationTask_Orientation_NORTH;
const NavigationTask_Orientation NavigationTask_Orientation_Orientation_MAX = NavigationTask_Orientation_WEST;
const int NavigationTask_Orientation_Orientation_ARRAYSIZE = NavigationTask_Orientation_Orientation_MAX + 1;

const ::google::protobuf::EnumDescriptor* NavigationTask_Orientation_descriptor();
inline const ::std::string& NavigationTask_Orientation_Name(NavigationTask_Orientation value) {
  return ::google::protobuf::internal::NameOfEnum(
    NavigationTask_Orientation_descriptor(), value);
}
inline bool NavigationTask_Orientation_Parse(
    const ::std::string& name, NavigationTask_Orientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationTask_Orientation>(
    NavigationTask_Orientation_descriptor(), name, value);
}
enum Task_Status {
  Task_Status_OFFERED = 1,
  Task_Status_TIMEOUT = 2,
  Task_Status_IN_PROGRESS = 3,
  Task_Status_PAUSED = 4,
  Task_Status_ABORTED = 5,
  Task_Status_FINISHED = 6
};
bool Task_Status_IsValid(int value);
const Task_Status Task_Status_Status_MIN = Task_Status_OFFERED;
const Task_Status Task_Status_Status_MAX = Task_Status_FINISHED;
const int Task_Status_Status_ARRAYSIZE = Task_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Task_Status_descriptor();
inline const ::std::string& Task_Status_Name(Task_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Task_Status_descriptor(), value);
}
inline bool Task_Status_Parse(
    const ::std::string& name, Task_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Task_Status>(
    Task_Status_descriptor(), name, value);
}
enum Task_TaskType {
  Task_TaskType_UNKNOWN = 0,
  Task_TaskType_TRANSPORTATION = 1,
  Task_TaskType_NAVIGATION = 2
};
bool Task_TaskType_IsValid(int value);
const Task_TaskType Task_TaskType_TaskType_MIN = Task_TaskType_UNKNOWN;
const Task_TaskType Task_TaskType_TaskType_MAX = Task_TaskType_NAVIGATION;
const int Task_TaskType_TaskType_ARRAYSIZE = Task_TaskType_TaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Task_TaskType_descriptor();
inline const ::std::string& Task_TaskType_Name(Task_TaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Task_TaskType_descriptor(), value);
}
inline bool Task_TaskType_Parse(
    const ::std::string& name, Task_TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Task_TaskType>(
    Task_TaskType_descriptor(), name, value);
}
// ===================================================================

class NavigationTask : public ::google::protobuf::Message {
 public:
  NavigationTask();
  virtual ~NavigationTask();

  NavigationTask(const NavigationTask& from);

  inline NavigationTask& operator=(const NavigationTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationTask& default_instance();

  void Swap(NavigationTask* other);

  // implements Message ----------------------------------------------

  NavigationTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NavigationTask& from);
  void MergeFrom(const NavigationTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NavigationTask_Orientation Orientation;
  static const Orientation NORTH = NavigationTask_Orientation_NORTH;
  static const Orientation EAST = NavigationTask_Orientation_EAST;
  static const Orientation SOUTH = NavigationTask_Orientation_SOUTH;
  static const Orientation WEST = NavigationTask_Orientation_WEST;
  static inline bool Orientation_IsValid(int value) {
    return NavigationTask_Orientation_IsValid(value);
  }
  static const Orientation Orientation_MIN =
    NavigationTask_Orientation_Orientation_MIN;
  static const Orientation Orientation_MAX =
    NavigationTask_Orientation_Orientation_MAX;
  static const int Orientation_ARRAYSIZE =
    NavigationTask_Orientation_Orientation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Orientation_descriptor() {
    return NavigationTask_Orientation_descriptor();
  }
  static inline const ::std::string& Orientation_Name(Orientation value) {
    return NavigationTask_Orientation_Name(value);
  }
  static inline bool Orientation_Parse(const ::std::string& name,
      Orientation* value) {
    return NavigationTask_Orientation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mission_protobuf.LocationIdentifier location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::mission_protobuf::LocationIdentifier& location() const;
  inline ::mission_protobuf::LocationIdentifier* mutable_location();
  inline ::mission_protobuf::LocationIdentifier* release_location();
  inline void set_allocated_location(::mission_protobuf::LocationIdentifier* location);

  // required .mission_protobuf.NavigationTask.Orientation orientation = 2;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  inline ::mission_protobuf::NavigationTask_Orientation orientation() const;
  inline void set_orientation(::mission_protobuf::NavigationTask_Orientation value);

  // required .mission_protobuf.Time wait_time = 3;
  inline bool has_wait_time() const;
  inline void clear_wait_time();
  static const int kWaitTimeFieldNumber = 3;
  inline const ::mission_protobuf::Time& wait_time() const;
  inline ::mission_protobuf::Time* mutable_wait_time();
  inline ::mission_protobuf::Time* release_wait_time();
  inline void set_allocated_wait_time(::mission_protobuf::Time* wait_time);

  // @@protoc_insertion_point(class_scope:mission_protobuf.NavigationTask)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_wait_time();
  inline void clear_has_wait_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mission_protobuf::LocationIdentifier* location_;
  ::mission_protobuf::Time* wait_time_;
  int orientation_;
  friend void  protobuf_AddDesc_task_5fspecification_2eproto();
  friend void protobuf_AssignDesc_task_5fspecification_2eproto();
  friend void protobuf_ShutdownFile_task_5fspecification_2eproto();

  void InitAsDefaultInstance();
  static NavigationTask* default_instance_;
};
// -------------------------------------------------------------------

class TransportationTask : public ::google::protobuf::Message {
 public:
  TransportationTask();
  virtual ~TransportationTask();

  TransportationTask(const TransportationTask& from);

  inline TransportationTask& operator=(const TransportationTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportationTask& default_instance();

  void Swap(TransportationTask* other);

  // implements Message ----------------------------------------------

  TransportationTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportationTask& from);
  void MergeFrom(const TransportationTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mission_protobuf.ObjectIdentifier object = 1;
  inline bool has_object() const;
  inline void clear_object();
  static const int kObjectFieldNumber = 1;
  inline const ::mission_protobuf::ObjectIdentifier& object() const;
  inline ::mission_protobuf::ObjectIdentifier* mutable_object();
  inline ::mission_protobuf::ObjectIdentifier* release_object();
  inline void set_allocated_object(::mission_protobuf::ObjectIdentifier* object);

  // optional .mission_protobuf.ObjectIdentifier container = 2;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 2;
  inline const ::mission_protobuf::ObjectIdentifier& container() const;
  inline ::mission_protobuf::ObjectIdentifier* mutable_container();
  inline ::mission_protobuf::ObjectIdentifier* release_container();
  inline void set_allocated_container(::mission_protobuf::ObjectIdentifier* container);

  // required uint64 quantity_delivered = 3;
  inline bool has_quantity_delivered() const;
  inline void clear_quantity_delivered();
  static const int kQuantityDeliveredFieldNumber = 3;
  inline ::google::protobuf::uint64 quantity_delivered() const;
  inline void set_quantity_delivered(::google::protobuf::uint64 value);

  // optional uint64 quantity_requested = 4;
  inline bool has_quantity_requested() const;
  inline void clear_quantity_requested();
  static const int kQuantityRequestedFieldNumber = 4;
  inline ::google::protobuf::uint64 quantity_requested() const;
  inline void set_quantity_requested(::google::protobuf::uint64 value);

  // optional .mission_protobuf.LocationIdentifier destination = 5;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 5;
  inline const ::mission_protobuf::LocationIdentifier& destination() const;
  inline ::mission_protobuf::LocationIdentifier* mutable_destination();
  inline ::mission_protobuf::LocationIdentifier* release_destination();
  inline void set_allocated_destination(::mission_protobuf::LocationIdentifier* destination);

  // optional .mission_protobuf.LocationIdentifier source = 6;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 6;
  inline const ::mission_protobuf::LocationIdentifier& source() const;
  inline ::mission_protobuf::LocationIdentifier* mutable_source();
  inline ::mission_protobuf::LocationIdentifier* release_source();
  inline void set_allocated_source(::mission_protobuf::LocationIdentifier* source);

  // optional string processing_team = 7;
  inline bool has_processing_team() const;
  inline void clear_processing_team();
  static const int kProcessingTeamFieldNumber = 7;
  inline const ::std::string& processing_team() const;
  inline void set_processing_team(const ::std::string& value);
  inline void set_processing_team(const char* value);
  inline void set_processing_team(const char* value, size_t size);
  inline ::std::string* mutable_processing_team();
  inline ::std::string* release_processing_team();
  inline void set_allocated_processing_team(::std::string* processing_team);

  // @@protoc_insertion_point(class_scope:mission_protobuf.TransportationTask)
 private:
  inline void set_has_object();
  inline void clear_has_object();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_quantity_delivered();
  inline void clear_has_quantity_delivered();
  inline void set_has_quantity_requested();
  inline void clear_has_quantity_requested();
  inline void set_has_destination();
  inline void clear_has_destination();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_processing_team();
  inline void clear_has_processing_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mission_protobuf::ObjectIdentifier* object_;
  ::mission_protobuf::ObjectIdentifier* container_;
  ::google::protobuf::uint64 quantity_delivered_;
  ::google::protobuf::uint64 quantity_requested_;
  ::mission_protobuf::LocationIdentifier* destination_;
  ::mission_protobuf::LocationIdentifier* source_;
  ::std::string* processing_team_;
  friend void  protobuf_AddDesc_task_5fspecification_2eproto();
  friend void protobuf_AssignDesc_task_5fspecification_2eproto();
  friend void protobuf_ShutdownFile_task_5fspecification_2eproto();

  void InitAsDefaultInstance();
  static TransportationTask* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Task_Status Status;
  static const Status OFFERED = Task_Status_OFFERED;
  static const Status TIMEOUT = Task_Status_TIMEOUT;
  static const Status IN_PROGRESS = Task_Status_IN_PROGRESS;
  static const Status PAUSED = Task_Status_PAUSED;
  static const Status ABORTED = Task_Status_ABORTED;
  static const Status FINISHED = Task_Status_FINISHED;
  static inline bool Status_IsValid(int value) {
    return Task_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Task_Status_Status_MIN;
  static const Status Status_MAX =
    Task_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Task_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Task_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Task_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Task_Status_Parse(name, value);
  }

  typedef Task_TaskType TaskType;
  static const TaskType UNKNOWN = Task_TaskType_UNKNOWN;
  static const TaskType TRANSPORTATION = Task_TaskType_TRANSPORTATION;
  static const TaskType NAVIGATION = Task_TaskType_NAVIGATION;
  static inline bool TaskType_IsValid(int value) {
    return Task_TaskType_IsValid(value);
  }
  static const TaskType TaskType_MIN =
    Task_TaskType_TaskType_MIN;
  static const TaskType TaskType_MAX =
    Task_TaskType_TaskType_MAX;
  static const int TaskType_ARRAYSIZE =
    Task_TaskType_TaskType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TaskType_descriptor() {
    return Task_TaskType_descriptor();
  }
  static inline const ::std::string& TaskType_Name(TaskType value) {
    return Task_TaskType_Name(value);
  }
  static inline bool TaskType_Parse(const ::std::string& name,
      TaskType* value) {
    return Task_TaskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required .mission_protobuf.Task.TaskType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mission_protobuf::Task_TaskType type() const;
  inline void set_type(::mission_protobuf::Task_TaskType value);

  // required .mission_protobuf.Task.Status status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::mission_protobuf::Task_Status status() const;
  inline void set_status(::mission_protobuf::Task_Status value);

  // optional .mission_protobuf.TransportationTask transportation_task = 4;
  inline bool has_transportation_task() const;
  inline void clear_transportation_task();
  static const int kTransportationTaskFieldNumber = 4;
  inline const ::mission_protobuf::TransportationTask& transportation_task() const;
  inline ::mission_protobuf::TransportationTask* mutable_transportation_task();
  inline ::mission_protobuf::TransportationTask* release_transportation_task();
  inline void set_allocated_transportation_task(::mission_protobuf::TransportationTask* transportation_task);

  // optional .mission_protobuf.NavigationTask navigation_task = 5;
  inline bool has_navigation_task() const;
  inline void clear_navigation_task();
  static const int kNavigationTaskFieldNumber = 5;
  inline const ::mission_protobuf::NavigationTask& navigation_task() const;
  inline ::mission_protobuf::NavigationTask* mutable_navigation_task();
  inline ::mission_protobuf::NavigationTask* release_navigation_task();
  inline void set_allocated_navigation_task(::mission_protobuf::NavigationTask* navigation_task);

  // @@protoc_insertion_point(class_scope:mission_protobuf.Task)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_transportation_task();
  inline void clear_has_transportation_task();
  inline void set_has_navigation_task();
  inline void clear_has_navigation_task();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  int type_;
  int status_;
  ::mission_protobuf::TransportationTask* transportation_task_;
  ::mission_protobuf::NavigationTask* navigation_task_;
  friend void  protobuf_AddDesc_task_5fspecification_2eproto();
  friend void protobuf_AssignDesc_task_5fspecification_2eproto();
  friend void protobuf_ShutdownFile_task_5fspecification_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// ===================================================================


// ===================================================================

// NavigationTask

// required .mission_protobuf.LocationIdentifier location = 1;
inline bool NavigationTask::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavigationTask::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavigationTask::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavigationTask::clear_location() {
  if (location_ != NULL) location_->::mission_protobuf::LocationIdentifier::Clear();
  clear_has_location();
}
inline const ::mission_protobuf::LocationIdentifier& NavigationTask::location() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.NavigationTask.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::mission_protobuf::LocationIdentifier* NavigationTask::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::mission_protobuf::LocationIdentifier;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.NavigationTask.location)
  return location_;
}
inline ::mission_protobuf::LocationIdentifier* NavigationTask::release_location() {
  clear_has_location();
  ::mission_protobuf::LocationIdentifier* temp = location_;
  location_ = NULL;
  return temp;
}
inline void NavigationTask::set_allocated_location(::mission_protobuf::LocationIdentifier* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.NavigationTask.location)
}

// required .mission_protobuf.NavigationTask.Orientation orientation = 2;
inline bool NavigationTask::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavigationTask::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavigationTask::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NavigationTask::clear_orientation() {
  orientation_ = 1;
  clear_has_orientation();
}
inline ::mission_protobuf::NavigationTask_Orientation NavigationTask::orientation() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.NavigationTask.orientation)
  return static_cast< ::mission_protobuf::NavigationTask_Orientation >(orientation_);
}
inline void NavigationTask::set_orientation(::mission_protobuf::NavigationTask_Orientation value) {
  assert(::mission_protobuf::NavigationTask_Orientation_IsValid(value));
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:mission_protobuf.NavigationTask.orientation)
}

// required .mission_protobuf.Time wait_time = 3;
inline bool NavigationTask::has_wait_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NavigationTask::set_has_wait_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NavigationTask::clear_has_wait_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NavigationTask::clear_wait_time() {
  if (wait_time_ != NULL) wait_time_->::mission_protobuf::Time::Clear();
  clear_has_wait_time();
}
inline const ::mission_protobuf::Time& NavigationTask::wait_time() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.NavigationTask.wait_time)
  return wait_time_ != NULL ? *wait_time_ : *default_instance_->wait_time_;
}
inline ::mission_protobuf::Time* NavigationTask::mutable_wait_time() {
  set_has_wait_time();
  if (wait_time_ == NULL) wait_time_ = new ::mission_protobuf::Time;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.NavigationTask.wait_time)
  return wait_time_;
}
inline ::mission_protobuf::Time* NavigationTask::release_wait_time() {
  clear_has_wait_time();
  ::mission_protobuf::Time* temp = wait_time_;
  wait_time_ = NULL;
  return temp;
}
inline void NavigationTask::set_allocated_wait_time(::mission_protobuf::Time* wait_time) {
  delete wait_time_;
  wait_time_ = wait_time;
  if (wait_time) {
    set_has_wait_time();
  } else {
    clear_has_wait_time();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.NavigationTask.wait_time)
}

// -------------------------------------------------------------------

// TransportationTask

// required .mission_protobuf.ObjectIdentifier object = 1;
inline bool TransportationTask::has_object() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportationTask::set_has_object() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportationTask::clear_has_object() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportationTask::clear_object() {
  if (object_ != NULL) object_->::mission_protobuf::ObjectIdentifier::Clear();
  clear_has_object();
}
inline const ::mission_protobuf::ObjectIdentifier& TransportationTask::object() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.TransportationTask.object)
  return object_ != NULL ? *object_ : *default_instance_->object_;
}
inline ::mission_protobuf::ObjectIdentifier* TransportationTask::mutable_object() {
  set_has_object();
  if (object_ == NULL) object_ = new ::mission_protobuf::ObjectIdentifier;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.TransportationTask.object)
  return object_;
}
inline ::mission_protobuf::ObjectIdentifier* TransportationTask::release_object() {
  clear_has_object();
  ::mission_protobuf::ObjectIdentifier* temp = object_;
  object_ = NULL;
  return temp;
}
inline void TransportationTask::set_allocated_object(::mission_protobuf::ObjectIdentifier* object) {
  delete object_;
  object_ = object;
  if (object) {
    set_has_object();
  } else {
    clear_has_object();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.TransportationTask.object)
}

// optional .mission_protobuf.ObjectIdentifier container = 2;
inline bool TransportationTask::has_container() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportationTask::set_has_container() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportationTask::clear_has_container() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportationTask::clear_container() {
  if (container_ != NULL) container_->::mission_protobuf::ObjectIdentifier::Clear();
  clear_has_container();
}
inline const ::mission_protobuf::ObjectIdentifier& TransportationTask::container() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.TransportationTask.container)
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::mission_protobuf::ObjectIdentifier* TransportationTask::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::mission_protobuf::ObjectIdentifier;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.TransportationTask.container)
  return container_;
}
inline ::mission_protobuf::ObjectIdentifier* TransportationTask::release_container() {
  clear_has_container();
  ::mission_protobuf::ObjectIdentifier* temp = container_;
  container_ = NULL;
  return temp;
}
inline void TransportationTask::set_allocated_container(::mission_protobuf::ObjectIdentifier* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.TransportationTask.container)
}

// required uint64 quantity_delivered = 3;
inline bool TransportationTask::has_quantity_delivered() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportationTask::set_has_quantity_delivered() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportationTask::clear_has_quantity_delivered() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportationTask::clear_quantity_delivered() {
  quantity_delivered_ = GOOGLE_ULONGLONG(0);
  clear_has_quantity_delivered();
}
inline ::google::protobuf::uint64 TransportationTask::quantity_delivered() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.TransportationTask.quantity_delivered)
  return quantity_delivered_;
}
inline void TransportationTask::set_quantity_delivered(::google::protobuf::uint64 value) {
  set_has_quantity_delivered();
  quantity_delivered_ = value;
  // @@protoc_insertion_point(field_set:mission_protobuf.TransportationTask.quantity_delivered)
}

// optional uint64 quantity_requested = 4;
inline bool TransportationTask::has_quantity_requested() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransportationTask::set_has_quantity_requested() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransportationTask::clear_has_quantity_requested() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransportationTask::clear_quantity_requested() {
  quantity_requested_ = GOOGLE_ULONGLONG(0);
  clear_has_quantity_requested();
}
inline ::google::protobuf::uint64 TransportationTask::quantity_requested() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.TransportationTask.quantity_requested)
  return quantity_requested_;
}
inline void TransportationTask::set_quantity_requested(::google::protobuf::uint64 value) {
  set_has_quantity_requested();
  quantity_requested_ = value;
  // @@protoc_insertion_point(field_set:mission_protobuf.TransportationTask.quantity_requested)
}

// optional .mission_protobuf.LocationIdentifier destination = 5;
inline bool TransportationTask::has_destination() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransportationTask::set_has_destination() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransportationTask::clear_has_destination() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransportationTask::clear_destination() {
  if (destination_ != NULL) destination_->::mission_protobuf::LocationIdentifier::Clear();
  clear_has_destination();
}
inline const ::mission_protobuf::LocationIdentifier& TransportationTask::destination() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.TransportationTask.destination)
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
}
inline ::mission_protobuf::LocationIdentifier* TransportationTask::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) destination_ = new ::mission_protobuf::LocationIdentifier;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.TransportationTask.destination)
  return destination_;
}
inline ::mission_protobuf::LocationIdentifier* TransportationTask::release_destination() {
  clear_has_destination();
  ::mission_protobuf::LocationIdentifier* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void TransportationTask::set_allocated_destination(::mission_protobuf::LocationIdentifier* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.TransportationTask.destination)
}

// optional .mission_protobuf.LocationIdentifier source = 6;
inline bool TransportationTask::has_source() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransportationTask::set_has_source() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransportationTask::clear_has_source() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransportationTask::clear_source() {
  if (source_ != NULL) source_->::mission_protobuf::LocationIdentifier::Clear();
  clear_has_source();
}
inline const ::mission_protobuf::LocationIdentifier& TransportationTask::source() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.TransportationTask.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::mission_protobuf::LocationIdentifier* TransportationTask::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::mission_protobuf::LocationIdentifier;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.TransportationTask.source)
  return source_;
}
inline ::mission_protobuf::LocationIdentifier* TransportationTask::release_source() {
  clear_has_source();
  ::mission_protobuf::LocationIdentifier* temp = source_;
  source_ = NULL;
  return temp;
}
inline void TransportationTask::set_allocated_source(::mission_protobuf::LocationIdentifier* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.TransportationTask.source)
}

// optional string processing_team = 7;
inline bool TransportationTask::has_processing_team() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransportationTask::set_has_processing_team() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransportationTask::clear_has_processing_team() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransportationTask::clear_processing_team() {
  if (processing_team_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processing_team_->clear();
  }
  clear_has_processing_team();
}
inline const ::std::string& TransportationTask::processing_team() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.TransportationTask.processing_team)
  return *processing_team_;
}
inline void TransportationTask::set_processing_team(const ::std::string& value) {
  set_has_processing_team();
  if (processing_team_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processing_team_ = new ::std::string;
  }
  processing_team_->assign(value);
  // @@protoc_insertion_point(field_set:mission_protobuf.TransportationTask.processing_team)
}
inline void TransportationTask::set_processing_team(const char* value) {
  set_has_processing_team();
  if (processing_team_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processing_team_ = new ::std::string;
  }
  processing_team_->assign(value);
  // @@protoc_insertion_point(field_set_char:mission_protobuf.TransportationTask.processing_team)
}
inline void TransportationTask::set_processing_team(const char* value, size_t size) {
  set_has_processing_team();
  if (processing_team_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processing_team_ = new ::std::string;
  }
  processing_team_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mission_protobuf.TransportationTask.processing_team)
}
inline ::std::string* TransportationTask::mutable_processing_team() {
  set_has_processing_team();
  if (processing_team_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processing_team_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mission_protobuf.TransportationTask.processing_team)
  return processing_team_;
}
inline ::std::string* TransportationTask::release_processing_team() {
  clear_has_processing_team();
  if (processing_team_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = processing_team_;
    processing_team_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransportationTask::set_allocated_processing_team(::std::string* processing_team) {
  if (processing_team_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete processing_team_;
  }
  if (processing_team) {
    set_has_processing_team();
    processing_team_ = processing_team;
  } else {
    clear_has_processing_team();
    processing_team_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.TransportationTask.processing_team)
}

// -------------------------------------------------------------------

// Task

// required uint64 id = 1;
inline bool Task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Task::id() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.Task.id)
  return id_;
}
inline void Task::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mission_protobuf.Task.id)
}

// required .mission_protobuf.Task.TaskType type = 2;
inline bool Task::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mission_protobuf::Task_TaskType Task::type() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.Task.type)
  return static_cast< ::mission_protobuf::Task_TaskType >(type_);
}
inline void Task::set_type(::mission_protobuf::Task_TaskType value) {
  assert(::mission_protobuf::Task_TaskType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mission_protobuf.Task.type)
}

// required .mission_protobuf.Task.Status status = 3;
inline bool Task::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::mission_protobuf::Task_Status Task::status() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.Task.status)
  return static_cast< ::mission_protobuf::Task_Status >(status_);
}
inline void Task::set_status(::mission_protobuf::Task_Status value) {
  assert(::mission_protobuf::Task_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mission_protobuf.Task.status)
}

// optional .mission_protobuf.TransportationTask transportation_task = 4;
inline bool Task::has_transportation_task() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_transportation_task() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_transportation_task() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_transportation_task() {
  if (transportation_task_ != NULL) transportation_task_->::mission_protobuf::TransportationTask::Clear();
  clear_has_transportation_task();
}
inline const ::mission_protobuf::TransportationTask& Task::transportation_task() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.Task.transportation_task)
  return transportation_task_ != NULL ? *transportation_task_ : *default_instance_->transportation_task_;
}
inline ::mission_protobuf::TransportationTask* Task::mutable_transportation_task() {
  set_has_transportation_task();
  if (transportation_task_ == NULL) transportation_task_ = new ::mission_protobuf::TransportationTask;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.Task.transportation_task)
  return transportation_task_;
}
inline ::mission_protobuf::TransportationTask* Task::release_transportation_task() {
  clear_has_transportation_task();
  ::mission_protobuf::TransportationTask* temp = transportation_task_;
  transportation_task_ = NULL;
  return temp;
}
inline void Task::set_allocated_transportation_task(::mission_protobuf::TransportationTask* transportation_task) {
  delete transportation_task_;
  transportation_task_ = transportation_task;
  if (transportation_task) {
    set_has_transportation_task();
  } else {
    clear_has_transportation_task();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.Task.transportation_task)
}

// optional .mission_protobuf.NavigationTask navigation_task = 5;
inline bool Task::has_navigation_task() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_navigation_task() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_navigation_task() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_navigation_task() {
  if (navigation_task_ != NULL) navigation_task_->::mission_protobuf::NavigationTask::Clear();
  clear_has_navigation_task();
}
inline const ::mission_protobuf::NavigationTask& Task::navigation_task() const {
  // @@protoc_insertion_point(field_get:mission_protobuf.Task.navigation_task)
  return navigation_task_ != NULL ? *navigation_task_ : *default_instance_->navigation_task_;
}
inline ::mission_protobuf::NavigationTask* Task::mutable_navigation_task() {
  set_has_navigation_task();
  if (navigation_task_ == NULL) navigation_task_ = new ::mission_protobuf::NavigationTask;
  // @@protoc_insertion_point(field_mutable:mission_protobuf.Task.navigation_task)
  return navigation_task_;
}
inline ::mission_protobuf::NavigationTask* Task::release_navigation_task() {
  clear_has_navigation_task();
  ::mission_protobuf::NavigationTask* temp = navigation_task_;
  navigation_task_ = NULL;
  return temp;
}
inline void Task::set_allocated_navigation_task(::mission_protobuf::NavigationTask* navigation_task) {
  delete navigation_task_;
  navigation_task_ = navigation_task;
  if (navigation_task) {
    set_has_navigation_task();
  } else {
    clear_has_navigation_task();
  }
  // @@protoc_insertion_point(field_set_allocated:mission_protobuf.Task.navigation_task)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mission_protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mission_protobuf::NavigationTask_Orientation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mission_protobuf::NavigationTask_Orientation>() {
  return ::mission_protobuf::NavigationTask_Orientation_descriptor();
}
template <> struct is_proto_enum< ::mission_protobuf::Task_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mission_protobuf::Task_Status>() {
  return ::mission_protobuf::Task_Status_descriptor();
}
template <> struct is_proto_enum< ::mission_protobuf::Task_TaskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mission_protobuf::Task_TaskType>() {
  return ::mission_protobuf::Task_TaskType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_5fspecification_2eproto__INCLUDED
